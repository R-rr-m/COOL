# PA5 代码生成器（Code Generator）完整指南

## 一、任务概述

### 1.1 任务目标

PA5要求实现COOL语言的代码生成器（Code Generator），将经过语义分析后的AST（抽象语法树）转换为MIPS汇编代码，最终可以在SPIM模拟器上运行。

### 1.2 核心要求

- **可以修改的文件**：`cgen.cc`、`cgen.h`、`cool-tree.h`、`cool-tree.handcode.h`
- **不能修改的文件**：`Makefile`、`cool-tree.cc`、`cgen-phase.cc`、`emit.h`、`cgen_supp.cc`中的特定函数
- **测试要求**：生成的汇编代码在SPIM上运行结果必须与官方版本完全一致

### 1.3 关键理解

**COOL语言特性**：
- COOL是表达式语言，所有语句都是表达式
- 代码生成采用递归方式，每个表达式节点递归生成其子表达式的代码
- 表达式求值结果存储在`$a0`（ACC寄存器）中

---

## 二、环境准备

### 2.1 链接必要文件

每次编译前，确保链接了官方的lexer、parser和semant：

```bash
cd /usr/class/assignments/PA5
ln -sf /usr/class/bin/lexer .
ln -sf /usr/class/bin/parser .
ln -sf /usr/class/bin/semant .
```

### 2.2 编译代码生成器

```bash
make clean      # 清理之前的编译文件
make cgen       # 编译代码生成器
```


### 2.3 测试编译

```bash
# 编译COOL程序生成.s文件
./lexer stack.cl | ./parser stack.cl 2>&1 | ./semant stack.cl 2>&1 | ./cgen -o stack_my.s stack.cl

# 或者使用mycoolc脚本（需要确保lexer、parser、semant已链接）
./mycoolc -o stack_my.s stack.cl
```

---

## 三、代码结构理解

### 3.1 关键文件说明

#### `cgen.cc` - 主要实现文件
包含所有表达式节点的`code()`方法实现，以及类表、方法表、对象初始化等代码生成逻辑。

#### `cgen.h` - 头文件
定义了`CgenClassTable`、`CgenNode`、`Environment`等关键类。

#### `cool-tree.h` - AST节点定义
定义了所有表达式节点类，需要添加辅助方法如`GetActuals()`、`GetCases()`等。

#### `cool-tree.handcode.h` - 手写实现
定义了`code()`方法的签名，需要修改为接受`Environment`参数。

### 3.2 核心数据结构

#### Environment类
用于跟踪代码生成时的环境信息：
- **变量查找**：查找let变量、参数、属性
- **作用域管理**：进入/退出作用域
- **类信息**：当前类节点

```cpp
class Environment {
public:
    int LookUpVar(Symbol sym);      // 查找let变量
    int LookUpParam(Symbol sym);    // 查找参数
    int LookUpAttrib(Symbol sym);   // 查找属性
    void EnterScope();               // 进入新作用域
    void ExitScope();                // 退出作用域
    void AddVar(Symbol sym);        // 添加变量
    void AddParam(Symbol sym);      // 添加参数
    CgenNode* m_class_node;         // 当前类节点
};
```

#### CgenClassTable类
管理类的代码生成：
- 生成类名表（class_nameTab）
- 生成对象表（class_objTab）
- 生成分发表（dispatch tables）
- 生成原型对象（prototype objects）
- 生成初始化方法（init methods）
- 生成类方法（class methods）

#### CgenNode类
表示一个类的代码生成节点：
- 获取类的所有方法（包括继承的）
- 获取类的所有属性（包括继承的）
- 生成原型对象代码
- 生成初始化代码
- 生成方法代码

---

## 四、代码生成流程

### 4.1 整体流程

```
AST (输入)
  ↓
program_class::cgen()
  ↓
CgenClassTable构造函数
  ↓
install_basic_classes()      # 安装基本类
install_classes()            # 安装用户类
build_inheritance_tree()     # 构建继承树
  ↓
CgenClassTable::code()
  ↓
code_global_data()           # 生成全局数据段
code_select_gc()             # 选择GC
code_constants()             # 生成常量
code_class_nameTab()         # 生成类名表
code_class_objTab()          # 生成对象表
code_dispatchTabs()          # 生成分发表
code_protObjs()              # 生成原型对象
code_global_text()           # 生成全局文本段
code_class_inits()           # 生成初始化方法
code_class_methods()         # 生成类方法
  ↓
MIPS汇编代码 (输出)
```

### 4.2 表达式代码生成模式

所有表达式的代码生成遵循以下模式：

```cpp
void expression_class::code(ostream& s, Environment env) {
    // 1. 生成子表达式的代码（递归）
    child_expr1->code(s, env);
    
    // 2. 保存结果（如果需要）
    emit_push(ACC, s);
    
    // 3. 生成其他子表达式的代码
    child_expr2->code(s, env);
    
    // 4. 恢复之前的结果（如果需要）
    emit_load(T1, 0, SP, s);
    emit_addiu(SP, SP, 4, s);
    
    // 5. 执行操作
    emit_add(ACC, T1, ACC, s);
    
    // 6. 结果已经在ACC中
}
```

**关键原则**：
- 表达式求值结果总是放在`$a0`（ACC）寄存器中
- 需要保存中间结果时，使用栈（SP寄存器）
- 栈向低地址增长（push时SP减小）

---

## 五、关键实现细节

### 5.1 基本类型常量

#### 整数常量（int_const_class）

```cpp
void int_const_class::code(ostream& s, Environment env) {
    // 从整数表中加载常量地址到ACC
    emit_load_int(ACC, inttable.lookup_string(token->get_string()), s);
}
```

#### 字符串常量（string_const_class）

```cpp
void string_const_class::code(ostream& s, Environment env) {
    // 从字符串表中加载常量地址到ACC
    emit_load_string(ACC, stringtable.lookup_string(token->get_string()), s);
}
```

#### 布尔常量（bool_const_class）

```cpp
void bool_const_class::code(ostream& s, Environment env) {
    // 加载布尔常量地址到ACC
    emit_load_bool(ACC, BoolConst(val), s);
}
```

### 5.2 对象引用（object_class）

对象引用需要区分三种情况：let变量、方法参数、类属性。

```cpp
void object_class::code(ostream& s, Environment env) {
    int idx;
    
    // 1. 查找let变量
    if ((idx = env.LookUpVar(name)) != -1) {
        emit_load(ACC, idx + 1, SP, s);  // 从栈中加载
    }
    // 2. 查找参数
    else if ((idx = env.LookUpParam(name)) != -1) {
        emit_load(ACC, idx + 3, FP, s);  // 从帧指针加载
    }
    // 3. 查找属性
    else if ((idx = env.LookUpAttrib(name)) != -1) {
        emit_load(ACC, idx + 3, SELF, s); // 从self对象加载
    }
    // 4. self引用
    else if (name == self) {
        emit_move(ACC, SELF, s);
    }
}
```

**注意**：
- let变量存储在栈上，偏移量从1开始（0是返回地址）
- 参数存储在帧指针（FP）上，偏移量从3开始（0-2是FP、SELF、RA）
- 属性存储在对象（SELF）上，偏移量从3开始（0-2是tag、size、dispatch table）

### 5.3 赋值表达式（assign_class）

```cpp
void assign_class::code(ostream& s, Environment env) {
    // 1. 先计算右侧表达式的值
    expr->code(s, env);
    
    // 2. 找到左侧变量的位置并存储
    int idx;
    if ((idx = env.LookUpVar(name)) != -1) {
        emit_store(ACC, idx + 1, SP, s);
    } else if ((idx = env.LookUpParam(name)) != -1) {
        emit_store(ACC, idx + 3, FP, s);
    } else if ((idx = env.LookUpAttrib(name)) != -1) {
        emit_store(ACC, idx + 3, SELF, s);
        // 如果需要GC，调用GC赋值函数
        if (cgen_Memmgr == 1) {
            emit_addiu(A1, SELF, 4 * (idx + 3), s);
            emit_jal("_GenGC_Assign", s);
        }
    }
}
```

### 5.4 算术运算（plus_class, sub_class等）

以加法为例：

```cpp
void plus_class::code(ostream& s, Environment env) {
    // 1. 计算e1并保存
    e1->code(s, env);
    emit_push(ACC, s);
    env.AddObstacle();  // 标记栈上有对象引用（用于GC）
    
    // 2. 计算e2并复制（因为要返回新对象）
    e2->code(s, env);
    emit_jal("Object.copy", s);  // 复制对象
    
    // 3. 恢复e1的值
    emit_addiu(SP, SP, 4, s);
    emit_load(T1, 0, SP, s);
    emit_move(T2, ACC, s);  // e2的结果在ACC中
    
    // 4. 提取整数部分（偏移3是val字段）
    emit_load(T1, 3, T1, s);  // T1 = e1.val
    emit_load(T2, 3, T2, s);  // T2 = e2.val
    
    // 5. 执行加法并存储
    emit_add(T3, T1, T2, s);
    emit_store(T3, 3, ACC, s);  // ACC.val = T1 + T2
}
```

**关键点**：
- 整数运算需要从对象中提取值（偏移3）
- 结果需要存储回对象（偏移3）
- 使用`Object.copy`创建新对象

### 5.5 条件表达式（cond_class）

```cpp
void cond_class::code(ostream& s, Environment env) {
    // 1. 计算条件表达式
    pred->code(s, env);
    
    // 2. 提取布尔值
    emit_fetch_int(T1, ACC, s);
    
    // 3. 生成标签
    int label_false = labelnum++;
    int label_finish = labelnum++;
    
    // 4. 条件跳转
    emit_beq(T1, ZERO, label_false, s);
    
    // 5. then分支
    then_exp->code(s, env);
    emit_branch(label_finish, s);
    
    // 6. else分支
    emit_label_def(label_false, s);
    else_exp->code(s, env);
    
    // 7. 结束标签
    emit_label_def(label_finish, s);
}
```

### 5.6 循环表达式（loop_class）

```cpp
void loop_class::code(ostream& s, Environment env) {
    int start = labelnum++;
    int finish = labelnum++;
    
    // 1. 开始标签
    emit_label_def(start, s);
    
    // 2. 计算条件
    pred->code(s, env);
    emit_fetch_int(T1, ACC, s);
    
    // 3. 如果条件为假，跳转到结束
    emit_beq(T1, ZERO, finish, s);
    
    // 4. 执行循环体
    body->code(s, env);
    
    // 5. 跳回开始
    emit_branch(start, s);
    
    // 6. 结束标签
    emit_label_def(finish, s);
    
    // 7. 循环表达式返回void
    emit_move(ACC, ZERO, s);
}
```

### 5.7 let表达式（let_class）

```cpp
void let_class::code(ostream& s, Environment env) {
    // 1. 计算初始值
    init->code(s, env);
    
    // 2. 如果没有初始值，使用默认值
    if (init->IsEmpty()) {
        if (type_decl == Str) {
            emit_load_string(ACC, stringtable.lookup_string(""), s);
        } else if (type_decl == Int) {
            emit_load_int(ACC, inttable.lookup_string("0"), s);
        } else if (type_decl == Bool) {
            emit_load_bool(ACC, BoolConst(0), s);
        }
    }
    
    // 3. 将初始值压栈
    emit_push(ACC, s);
    
    // 4. 进入新作用域并添加变量
    env.EnterScope();
    env.AddVar(identifier);
    
    // 5. 计算body表达式
    body->code(s, env);
    
    // 6. 退出作用域（弹出变量）
    emit_addiu(SP, SP, 4, s);
}
```

### 5.8 方法调用（dispatch_class）

```cpp
void dispatch_class::code(ostream& s, Environment env) {
    // 1. 计算所有参数并压栈（从右到左）
    std::vector<Expression> actuals = GetActuals();
    for (Expression expr : actuals) {
        expr->code(s, env);
        emit_push(ACC, s);
        env.AddObstacle();
    }
    
    // 2. 计算对象表达式
    expr->code(s, env);
    
    // 3. 检查对象是否为void
    emit_bne(ACC, ZERO, labelnum, s);
    emit_load_address(ACC, "str_const0", s);
    emit_load_imm(T1, 1, s);
    emit_jal("_dispatch_abort", s);
    emit_label_def(labelnum, s);
    ++labelnum;
    
    // 4. 确定方法所在的类
    Symbol class_name = env.m_class_node->name;
    if (expr->get_type() != SELF_TYPE) {
        class_name = expr->get_type();
    }
    
    // 5. 加载分发表
    emit_load(T1, 2, ACC, s);  // T1 = ACC.dispatch_table
    
    // 6. 获取方法索引
    CgenNode* class_node = codegen_classtable->GetClassNode(class_name);
    int idx = class_node->GetDispatchIdxTab()[name];
    
    // 7. 加载方法地址
    emit_load(T1, idx, T1, s);
    
    // 8. 调用方法
    emit_jalr(T1, s);
}
```

### 5.9 new表达式（new__class）

```cpp
void new__class::code(ostream& s, Environment env) {
    if (type_name == SELF_TYPE) {
        // SELF_TYPE需要运行时确定
        emit_load_address(T1, "class_objTab", s);
        emit_load(T2, 0, SELF, s);  // T2 = self的类标签
        emit_sll(T2, T2, 3, s);      // 乘以8（每个类在objTab中占2个字）
        emit_addu(T1, T1, T2, s);
        emit_push(T1, s);
        emit_load(ACC, 0, T1, s);    // 加载protObj
        emit_jal("Object.copy", s);
        emit_load(T1, 1, SP, s);
        emit_addiu(SP, SP, 4, s);
        emit_load(T1, 1, T1, s);     // 加载init地址
        emit_jalr(T1, s);
    } else {
        // 静态类型，直接加载protObj
        std::string protobj = type_name->get_string() + PROTOBJ_SUFFIX;
        emit_load_address(ACC, protobj.c_str(), s);
        emit_jal("Object.copy", s);
        std::string init = type_name->get_string() + CLASSINIT_SUFFIX;
        emit_jal(init.c_str(), s);
    }
}
```

### 5.10 块表达式（block_class）

```cpp
void block_class::code(ostream& s, Environment env) {
    // 依次执行所有表达式，最后一个表达式的值作为块的值
    for (int i = body->first(); body->more(i); i = body->next(i)) {
        body->nth(i)->code(s, env);
    }
}
```

---

## 六、类和方法代码生成

### 6.1 类名表（class_nameTab）

存储所有类的名称字符串地址：

```cpp
void CgenClassTable::code_class_nameTab() {
    str << CLASSNAMETAB << LABEL;
    std::vector<CgenNode*> class_nodes = GetClassNodes();
    for (CgenNode* class_node : class_nodes) {
        Symbol class_name = class_node->name;
        StringEntry* str_entry = stringtable.lookup_string(class_name->get_string());
        str << WORD;
        str_entry->code_ref(str);
        str << endl;
    }
}
```

### 6.2 对象表（class_objTab）

每个类占两个条目：protObj地址和init方法地址：

```cpp
void CgenClassTable::code_class_objTab() {
    str << CLASSOBJTAB << LABEL;
    std::vector<CgenNode*> class_nodes = GetClassNodes();
    for (CgenNode* class_node : class_nodes) {
        str << WORD;
        emit_protobj_ref(class_node->name, str);
        str << endl;
        str << WORD;
        emit_init_ref(class_node->name, str);
        str << endl;
    }
}
```

### 6.3 分发表（dispatch tables）

每个类一个分发表，包含所有方法的地址：

```cpp
void CgenClassTable::code_dispatchTabs() {
    std::vector<CgenNode*> class_nodes = GetClassNodes();
    for (CgenNode* class_node : class_nodes) {
        emit_disptable_ref(class_node->name, str);
        str << LABEL;
        std::vector<method_class*> methods = class_node->GetFullMethods();
        std::map<Symbol, int> idx_tab = class_node->GetDispatchIdxTab();
        for (method_class* method : methods) {
            str << WORD;
            emit_method_ref(class_node->name, method->name, str);
            str << endl;
        }
    }
}
```

### 6.4 原型对象（prototype objects）

每个类一个原型对象，包含类标签、大小、分发表地址和所有属性的初始值：

```cpp
void CgenNode::code_protObj(ostream& s) {
    std::vector<attr_class*> attribs = GetFullAttribs();
    
    s << WORD << "-1" << endl;  // GC标记
    s << get_name() << PROTOBJ_SUFFIX << LABEL;
    s << WORD << class_tag << "\t# class tag" << endl;
    s << WORD << (DEFAULT_OBJFIELDS + attribs.size()) << "\t# size" << endl;
    s << WORD << get_name() << DISPTAB_SUFFIX << endl;
    
    // 为每个属性生成初始值
    for (attr_class* attr : attribs) {
        if (attr->type_decl == Int) {
            s << WORD;
            inttable.lookup_string("0")->code_ref(s);
            s << "\t# int(0)" << endl;
        } else if (attr->type_decl == Bool) {
            s << WORD;
            falsebool.code_ref(s);
            s << "\t# bool(0)" << endl;
        } else if (attr->type_decl == Str) {
            s << WORD;
            stringtable.lookup_string("")->code_ref(s);
            s << "\t# str()" << endl;
        } else {
            s << WORD << "0\t# void" << endl;
        }
    }
}
```

### 6.5 初始化方法（init methods）

```cpp
void CgenNode::code_init(ostream& s) {
    s << get_name() << CLASSINIT_SUFFIX << LABEL;
    
    // 1. 保存寄存器
    emit_addiu(SP, SP, -12, s);
    emit_store(FP, 3, SP, s);
    emit_store(SELF, 2, SP, s);
    emit_store(RA, 1, SP, s);
    emit_addiu(FP, SP, 4, s);
    emit_move(SELF, ACC, s);
    
    // 2. 调用父类init
    Symbol parent = get_parentnd()->name;
    if (parent != No_class) {
        emit_jal(parent->get_string() + CLASSINIT_SUFFIX, s);
    }
    
    // 3. 初始化属性
    std::vector<attr_class*> attribs = GetAttribs();
    std::map<Symbol, int> idx_tab = GetAttribIdxTab();
    for (attr_class* attr : attribs) {
        int idx = idx_tab[attr->name];
        if (attr->init->IsEmpty()) {
            // 使用默认值
            if (attr->type_decl == Str) {
                emit_load_string(ACC, stringtable.lookup_string(""), s);
            } else if (attr->type_decl == Int) {
                emit_load_int(ACC, inttable.lookup_string("0"), s);
            } else if (attr->type_decl == Bool) {
                emit_load_bool(ACC, BoolConst(0), s);
            }
        } else {
            // 计算初始表达式
            Environment env;
            env.m_class_node = this;
            attr->init->code(s, env);
        }
        emit_store(ACC, 3 + idx, SELF, s);
    }
    
    // 4. 返回self
    emit_move(ACC, SELF, s);
    
    // 5. 恢复寄存器
    emit_load(FP, 3, SP, s);
    emit_load(SELF, 2, SP, s);
    emit_load(RA, 1, SP, s);
    emit_addiu(SP, SP, 12, s);
    emit_return(s);
}
```

### 6.6 方法代码生成

```cpp
void method_class::code(ostream& s, CgenNode* class_node) {
    emit_method_ref(class_node->name, name, s);
    s << LABEL;
    
    // 1. 保存寄存器
    emit_addiu(SP, SP, -12, s);
    emit_store(FP, 3, SP, s);
    emit_store(SELF, 2, SP, s);
    emit_store(RA, 1, SP, s);
    emit_addiu(FP, SP, 4, s);
    emit_move(SELF, ACC, s);
    
    // 2. 设置参数环境
    Environment env;
    env.m_class_node = class_node;
    for (int i = formals->first(); formals->more(i); i = formals->next(i)) {
        env.AddParam(formals->nth(i)->GetName());
    }
    
    // 3. 生成方法体代码
    expr->code(s, env);
    
    // 4. 恢复寄存器
    emit_load(FP, 3, SP, s);
    emit_load(SELF, 2, SP, s);
    emit_load(RA, 1, SP, s);
    emit_addiu(SP, SP, 12, s);
    
    // 5. 弹出参数
    emit_addiu(SP, SP, GetArgNum() * 4, s);
    
    // 6. 返回
    emit_return(s);
}
```

---

## 七、测试方法

### 7.1 编译测试

```bash
# 1. 确保链接了必要的文件
ln -sf /usr/class/bin/lexer .
ln -sf /usr/class/bin/parser .
ln -sf /usr/class/bin/semant .

# 2. 编译代码生成器
make clean
make cgen

# 3. 编译COOL程序
./lexer stack.cl | ./parser stack.cl 2>&1 | ./semant stack.cl 2>&1 | ./cgen -o stack_my.s stack.cl
```

### 7.2 运行测试

```bash
# 使用spim运行生成的汇编代码
/usr/class/bin/spim -file stack_my.s
```

### 7.3 对比测试

```bash
# 1. 生成官方版本
/usr/class/bin/coolc stack.cl

# 2. 生成自己的版本
./lexer stack.cl | ./parser stack.cl 2>&1 | ./semant stack.cl 2>&1 | ./cgen -o stack_my.s stack.cl

# 3. 运行并对比输出
/usr/class/bin/spim -file stack.s > stack_official.txt 2>&1
/usr/class/bin/spim -file stack_my.s > stack_my.txt 2>&1
diff stack_official.txt stack_my.txt

# 如果diff没有输出，说明完全一致！
```

### 7.4 调试技巧

#### 使用gdb调试

```bash
# 1. 准备输入
./lexer stack.cl | ./parser stack.cl 2>&1 | ./semant stack.cl 2>&1 > /tmp/ast.txt

# 2. 使用gdb运行
gdb ./cgen
(gdb) run -o stack_my.s stack.cl < /tmp/ast.txt

# 3. 设置断点
(gdb) break assign_class::code
(gdb) break dispatch_class::code
```

#### 查看生成的汇编代码

```bash
# 查看前100行
head -100 stack_my.s

# 搜索特定符号
grep "Main_init" stack_my.s

# 对比两个.s文件的结构
diff <(head -200 stack.s) <(head -200 stack_my.s)
```

---

## 八、常见问题和注意事项

### 8.1 编译错误

#### 错误：找不到GetActuals()方法

**原因**：`cool-tree.h`中缺少辅助方法定义。

**解决**：在`dispatch_class`和`static_dispatch_class`中添加：

```cpp
std::vector<Expression> GetActuals() {
    std::vector<Expression> ret;
    for (int i = actual->first(); actual->more(i); i = actual->next(i)) {
        ret.push_back(actual->nth(i));
    }
    return ret;
}
```

#### 错误：code()函数签名不匹配

**原因**：`cool-tree.handcode.h`中`code()`函数签名需要接受`Environment`参数。

**解决**：修改`Expression_EXTRAS`宏：

```cpp
#define Expression_EXTRAS                    \
Symbol type;                                 \
Symbol get_type() { return type; }           \
Expression set_type(Symbol s) { type = s; return this; } \
virtual void code(ostream&, Environment) = 0; \
...
```

### 8.2 运行时错误

#### 错误：未定义的符号（undefined symbol）

**原因**：某些全局符号没有生成。

**检查**：
1. `code_global_data()`是否正确生成全局符号声明
2. `code_class_nameTab()`是否正确生成类名表
3. `code_class_objTab()`是否正确生成对象表
4. `code_protObjs()`是否正确生成原型对象

#### 错误：段错误（segmentation fault）

**原因**：可能是空指针解引用或栈溢出。

**调试**：
1. 检查所有指针使用前是否为空
2. 检查栈操作是否匹配（push和pop成对）
3. 使用gdb定位崩溃位置

### 8.3 逻辑错误

#### 问题：表达式值不正确

**检查**：
1. 是否正确保存和恢复中间结果
2. 寄存器使用是否正确（ACC用于结果，T1-T3用于临时值）
3. 栈操作是否正确

#### 问题：方法调用失败

**检查**：
1. 分发表索引是否正确
2. 参数传递顺序是否正确（从右到左）
3. 方法查找是否考虑了继承

### 8.4 重要注意事项

1. **栈操作必须成对**：每次`emit_push`后必须有对应的`emit_addiu(SP, SP, 4, s)`

2. **寄存器约定**：
   - `ACC`（$a0）：表达式结果
   - `SELF`（$s0）：当前对象
   - `FP`（$fp）：帧指针
   - `SP`（$sp）：栈指针
   - `T1-T3`（$t1-$t3）：临时寄存器

3. **对象布局**：
   - 偏移0：类标签（tag）
   - 偏移1：对象大小（size）
   - 偏移2：分发表地址（dispatch table）
   - 偏移3+：属性（attributes）

4. **方法调用约定**：
   - 参数从右到左压栈
   - 调用者负责清理参数
   - 方法返回时，结果在ACC中

5. **标签管理**：
   - 使用全局`labelnum`变量生成唯一标签
   - 每次使用后递增

---

## 九、实现步骤建议

### 步骤1：理解代码结构

1. 阅读`cgen.cc`中的骨架代码
2. 理解`Environment`类的作用
3. 理解`CgenClassTable`和`CgenNode`的关系

### 步骤2：实现简单表达式

1. 常量表达式（int_const, string_const, bool_const）
2. 对象引用（object_class）
3. 赋值表达式（assign_class）

### 步骤3：实现算术运算

1. 一元运算（neg_class）
2. 二元运算（plus_class, sub_class等）

### 步骤4：实现控制流

1. 条件表达式（cond_class）
2. 循环表达式（loop_class）
3. 块表达式（block_class）

### 步骤5：实现复杂表达式

1. let表达式（let_class）
2. 方法调用（dispatch_class）
3. new表达式（new__class）

### 步骤6：实现类和方法

1. 类名表和对象表
2. 分发表
3. 原型对象
4. 初始化方法
5. 类方法

### 步骤7：测试和调试

1. 使用简单测试用例
2. 使用stack.cl测试
3. 使用complex.cl测试
4. 对比官方输出

---

## 十、代码片段参考

### 10.1 完整的assign_class实现

```cpp
void assign_class::code(ostream& s, Environment env) {
    s << "\t# Assign. First eval the expr." << endl;
    expr->code(s, env);

    s << "\t# Now find the lvalue." << endl;
    int idx;

    if ((idx = env.LookUpVar(name)) != -1) {
        s << "\t# It is a let variable." << endl;
        emit_store(ACC, idx + 1, SP, s);
        if (cgen_Memmgr == 1) {
            emit_addiu(A1, SP, 4 * (idx + 1), s);
            emit_jal("_GenGC_Assign", s);
        }
    } else if ((idx = env.LookUpParam(name)) != -1){
        s << "\t# It is a param." << endl;
        emit_store(ACC, idx + 3, FP, s);
        if (cgen_Memmgr == 1) {
            emit_addiu(A1, FP, 4 * (idx + 3), s);
            emit_jal("_GenGC_Assign", s);
        }
    } else if ((idx = env.LookUpAttrib(name)) != -1) {
        s << "\t# It is an attribute." << endl;
        emit_store(ACC, idx + 3, SELF, s);
        if (cgen_Memmgr == 1) {
            emit_addiu(A1, SELF, 4 * (idx + 3), s);
            emit_jal("_GenGC_Assign", s);
        }
    } else {
        s << "Error! assign to what?" << endl;
    }
}
```

### 10.2 完整的plus_class实现

```cpp
void plus_class::code(ostream& s, Environment env) {
    s << "\t# Int operation : Add" << endl;
    s << "\t# First eval e1 and push." << endl;
    e1->code(s, env);
    emit_push(ACC, s);
    env.AddObstacle();
    s << endl;

    s << "\t# Then eval e2 and make a copy for result." << endl;
    e2->code(s, env);
    emit_jal("Object.copy", s);
    s << endl;

    s << "\t# Let's pop e1 to t1, move e2 to t2" << endl;
    emit_addiu(SP, SP, 4, s);
    emit_load(T1, 0, SP, s);
    emit_move(T2, ACC, s);
    s << endl;

    s << "\t# Extract the int inside the object." << endl;
    emit_load(T1, 3, T1, s);
    emit_load(T2, 3, T2, s);
    s << endl;

    s << "\t# Modify the int inside t2." << endl;
    emit_add(T3, T1, T2, s);
    emit_store(T3, 3, ACC, s);
    s << endl;
}
```

### 10.3 完整的dispatch_class实现

```cpp
void dispatch_class::code(ostream& s, Environment env) {
    s << "\t# Dispatch. First eval and save the params." << endl;
    std::vector<Expression> actuals = GetActuals();

    for (Expression expr : actuals) {
        expr->code(s, env);
        emit_push(ACC, s);
        env.AddObstacle();
    }

    s << "\t# eval the obj in dispatch." << endl;
    expr->code(s, env);

    s << "\t# if obj = void: abort" << endl;
    emit_bne(ACC, ZERO, labelnum, s);
    s << LA << ACC << " str_const0" << endl;
    emit_load_imm(T1, 1, s);
    emit_jal("_dispatch_abort", s);

    emit_label_def(labelnum, s);
    ++labelnum;

    // Get current class name;
    Symbol _class_name = env.m_class_node->name;
    if (expr->get_type() != SELF_TYPE) {
        _class_name = expr->get_type();
    }

    CgenNode* _class_node = codegen_classtable->GetClassNode(_class_name);
    s << "\t# Now we locate the method in the dispatch table." << endl;
    s << "\t# t1 = self.dispTab" << endl;
    emit_load(T1, 2, ACC, s);
    s << endl;

    int idx = _class_node->GetDispatchIdxTab()[name];
    s << "\t# t1 = dispTab[offset]" << endl;
    emit_load(T1, idx, T1, s);
    s << endl;

    s << "\t# jumpto " << name << endl;
    emit_jalr(T1, s);
    s << endl;
}
```

---

## 十一、总结

PA5代码生成器是一个复杂的作业，需要：

1. **理解MIPS汇编**：了解寄存器、栈、调用约定
2. **理解COOL运行时**：对象布局、分发表、GC
3. **递归代码生成**：每个表达式递归生成子表达式代码
4. **环境管理**：正确跟踪变量、参数、属性的位置
5. **仔细测试**：确保生成的代码与官方版本行为一致

**关键成功因素**：
- 仔细阅读和理解现有代码
- 逐步实现和测试
- 使用gdb调试定位问题
- 始终与官方输出对比

---

## 十二、常量定义详解

在PA5中，需要为程序中出现的所有常量生成MIPS汇编代码。常量包括：**字符串常量**、**整数常量**和**布尔常量**。

### 12.1 常量生成的总体流程

在`CgenClassTable::code()`中，常量生成在`code_constants()`函数中完成：

```cpp
void CgenClassTable::code_constants() {
    // 添加必需的常量
    stringtable.add_string("");      // 空字符串
    inttable.add_string("0");       // 整数0
    
    // 生成所有字符串常量
    stringtable.code_string_table(str, stringclasstag);
    
    // 生成所有整数常量
    inttable.code_string_table(str, intclasstag);
    
    // 生成布尔常量（true和false）
    code_bools(boolclasstag);
}
```

**生成顺序**：
1. 字符串常量表
2. 整数常量表
3. 布尔常量（true和false）

### 12.2 字符串常量（String Constants）

#### 12.2.1 字符串常量的结构

字符串常量在内存中的布局：

```
偏移  内容              说明
----  ----------------  -------------------------
-4    -1               GC标记（eye catcher）
0     class tag        字符串类的标签
4     size             对象大小（包括字符串数据）
8     dispatch table   分发表地址
12    length           字符串长度（Int对象）
16    str_data         字符串数据（ASCII）
...   ...              对齐到字边界
```

#### 12.2.2 字符串常量的生成代码

```cpp
void StringEntry::code_def(ostream& s, int stringclasstag) {
    // 获取字符串长度的IntEntry
    IntEntryP lensym = inttable.add_int(len);
    
    // GC标记
    s << WORD << "-1" << endl;
    
    // 标签定义
    code_ref(s);  // 生成: str_const0:
    s << LABEL;
    
    // 类标签
    s << WORD << stringclasstag << endl;
    
    // 对象大小 = 默认字段(3) + 字符串槽(1) + 字符串数据大小
    s << WORD << (DEFAULT_OBJFIELDS + STRING_SLOTS + (len + 4) / 4) << endl;
    
    // 分发表地址
    s << WORD << Str << DISPTAB_SUFFIX << endl;
    
    // 字符串长度（Int对象引用）
    s << WORD;
    lensym->code_ref(s);  // 生成: int_const0
    s << endl;
    
    // 字符串数据
    emit_string_constant(s, str);
    
    // 对齐到字边界
    s << ALIGN;
}
```

#### 12.2.3 字符串常量的引用

```cpp
void StringEntry::code_ref(ostream& s) {
    s << STRCONST_PREFIX << index;  // 生成: str_const0, str_const1, ...
}
```

**示例**：对于字符串`"Hello"`，生成的代码：

```mips
.word -1
str_const0:
.word 4          # String类的标签（假设）
.word 6          # 大小：3(默认) + 1(长度) + 2(字符串数据，5字节对齐到8字节)
.word String_dispTab
.word int_const1  # 长度5的Int对象
.ascii "Hello"
.byte 0x0
.align 2
```

### 12.3 整数常量（Integer Constants）

#### 12.3.1 整数常量的结构

整数常量在内存中的布局：

```
偏移  内容              说明
----  ----------------  -------------------------
-4    -1               GC标记（eye catcher）
0     class tag        Int类的标签
4     size             对象大小（固定为4）
8     dispatch table   分发表地址
12    val              整数值（32位整数）
```

#### 12.3.2 整数常量的生成代码

```cpp
void IntEntry::code_def(ostream& s, int intclasstag) {
    // GC标记
    s << WORD << "-1" << endl;
    
    // 标签定义
    code_ref(s);  // 生成: int_const0:
    s << LABEL;
    
    // 类标签
    s << WORD << intclasstag << endl;
    
    // 对象大小 = 默认字段(3) + Int槽(1)
    s << WORD << (DEFAULT_OBJFIELDS + INT_SLOTS) << endl;
    
    // 分发表地址
    s << WORD << Int << DISPTAB_SUFFIX << endl;
    
    // 整数值
    s << WORD << str << endl;  // str是字符串形式的整数值
}
```

#### 12.3.3 整数常量的引用

```cpp
void IntEntry::code_ref(ostream& s) {
    s << INTCONST_PREFIX << index;  // 生成: int_const0, int_const1, ...
}
```

**示例**：对于整数`42`，生成的代码：

```mips
.word -1
int_const0:
.word 2          # Int类的标签（假设）
.word 4          # 大小：3(默认) + 1(val)
.word Int_dispTab
.word 42         # 整数值
```

### 12.4 布尔常量（Boolean Constants）

#### 12.4.1 布尔常量的结构

布尔常量在内存中的布局：

```
偏移  内容              说明
----  ----------------  -------------------------
-4    -1               GC标记（eye catcher）
0     class tag        Bool类的标签
4     size             对象大小（固定为4）
8     dispatch table   分发表地址
12    val              布尔值（0或1）
```

#### 12.4.2 布尔常量的生成代码

```cpp
void BoolConst::code_def(ostream& s, int boolclasstag) {
    // GC标记
    s << WORD << "-1" << endl;
    
    // 标签定义
    code_ref(s);  // 生成: bool_const0 或 bool_const1
    s << LABEL;
    
    // 类标签
    s << WORD << boolclasstag << endl;
    
    // 对象大小 = 默认字段(3) + Bool槽(1)
    s << WORD << (DEFAULT_OBJFIELDS + BOOL_SLOTS) << endl;
    
    // 分发表地址
    s << WORD << Bool << DISPTAB_SUFFIX << endl;
    
    // 布尔值（0或1）
    s << WORD << val << endl;
}
```

#### 12.4.3 布尔常量的引用

```cpp
void BoolConst::code_ref(ostream& s) const {
    s << BOOLCONST_PREFIX << val;  // 生成: bool_const0 或 bool_const1
}
```

**示例**：对于`true`和`false`，生成的代码：

```mips
# false
.word -1
bool_const0:
.word 3          # Bool类的标签（假设）
.word 4          # 大小：3(默认) + 1(val)
.word Bool_dispTab
.word 0          # false值

# true
.word -1
bool_const1:
.word 3          # Bool类的标签
.word 4          # 大小
.word Bool_dispTab
.word 1          # true值
```

### 12.5 常量在代码中的使用

#### 12.5.1 加载字符串常量

```cpp
void string_const_class::code(ostream& s, Environment env) {
    emit_load_string(ACC, stringtable.lookup_string(token->get_string()), s);
    // 生成: la $a0, str_const0
}
```

#### 12.5.2 加载整数常量

```cpp
void int_const_class::code(ostream& s, Environment env) {
    emit_load_int(ACC, inttable.lookup_string(token->get_string()), s);
    // 生成: la $a0, int_const0
}
```

#### 12.5.3 加载布尔常量

```cpp
void bool_const_class::code(ostream& s, Environment env) {
    emit_load_bool(ACC, BoolConst(val), s);
    // 生成: la $a0, bool_const0 或 bool_const1
}
```

### 12.6 常量表的组织

#### 12.6.1 字符串表（StringTable）

- **作用**：存储程序中出现的所有字符串字面量
- **去重**：相同的字符串只存储一次
- **索引**：每个字符串有唯一的索引（`index`）
- **命名**：`str_const0`, `str_const1`, ...

#### 12.6.2 整数表（IntTable）

- **作用**：存储程序中出现的所有整数字面量
- **去重**：相同的整数只存储一次
- **索引**：每个整数有唯一的索引（`index`）
- **命名**：`int_const0`, `int_const1`, ...

#### 12.6.3 布尔常量

- **固定两个**：`bool_const0`（false）和`bool_const1`（true）
- **全局定义**：在`code_bools()`中生成

### 12.7 常量生成的注意事项

1. **GC标记**：每个常量对象前都有一个`-1`作为GC标记（eye catcher）

2. **对齐**：字符串数据需要对齐到字边界（`.align 2`）

3. **大小计算**：
   - 字符串大小 = `3 + 1 + (len + 4) / 4`
   - 整数大小 = `3 + 1 = 4`
   - 布尔大小 = `3 + 1 = 4`

4. **依赖关系**：
   - 字符串常量依赖整数常量（长度）
   - 需要先确保整数常量已添加到表中

5. **引用方式**：
   - 使用`code_ref()`生成标签引用
   - 使用`la`指令加载常量地址到寄存器

### 12.8 完整示例

假设有以下COOL代码：

```cool
class Main {
    main() : Object {
        let x : Int <- 42 in
        let s : String <- "Hello" in
        if true then x else 0
        fi
    };
};
```

生成的常量部分：

```mips
.data
.align 2

# 字符串常量
.word -1
str_const0:
.word 4          # String类标签
.word 6          # 大小
.word String_dispTab
.word int_const1  # 长度5
.ascii "Hello"
.byte 0x0
.align 2

# 整数常量
.word -1
int_const0:
.word 2          # Int类标签
.word 4          # 大小
.word Int_dispTab
.word 0          # 值0

.word -1
int_const1:
.word 2          # Int类标签
.word 4          # 大小
.word Int_dispTab
.word 5          # 值5（字符串长度）

.word -1
int_const2:
.word 2          # Int类标签
.word 4          # 大小
.word Int_dispTab
.word 42         # 值42

# 布尔常量
.word -1
bool_const0:
.word 3          # Bool类标签
.word 4          # 大小
.word Bool_dispTab
.word 0          # false

.word -1
bool_const1:
.word 3          # Bool类标签
.word 4          # 大小
.word Bool_dispTab
.word 1          # true
```

---

## 十三、MIPS汇编指令详解

PA5代码生成器需要生成MIPS汇编代码。本节详细介绍PA5中会用到的所有MIPS指令和寄存器。

### 12.1 MIPS寄存器

MIPS有32个通用寄存器，PA5中主要使用以下寄存器：

| 寄存器名 | 编号 | 用途 | 说明 |
|---------|------|------|------|
| `$zero` | $0 | 零寄存器 | 值恒为0，不能写入 |
| `$a0` (ACC) | $4 | 累加器 | **表达式结果总是放在这里** |
| `$a1` | $5 | 参数寄存器 | 用于GC函数参数 |
| `$s0` (SELF) | $16 | 当前对象指针 | 指向当前对象（self） |
| `$t1` | $9 | 临时寄存器1 | 用于临时计算 |
| `$t2` | $10 | 临时寄存器2 | 用于临时计算 |
| `$t3` | $11 | 临时寄存器3 | 用于临时计算 |
| `$sp` | $29 | 栈指针 | 指向栈顶（栈向低地址增长） |
| `$fp` | $30 | 帧指针 | 指向当前栈帧 |
| `$ra` | $31 | 返回地址 | 存储函数返回地址 |

**重要约定**：
- **ACC（$a0）**：所有表达式求值的结果必须放在ACC中
- **SELF（$s0）**：方法调用时，当前对象（self）在SELF中
- **栈增长方向**：向低地址增长（push时SP减小，pop时SP增大）

### 12.2 数据传送指令

#### 12.2.1 加载指令

**`lw` (Load Word)** - 从内存加载一个字（4字节）到寄存器

```mips
lw $dest, offset($base)
```

**功能**：`$dest = Memory[$base + offset]`

**示例**：
```mips
lw $a0, 12($s0)    # 从SELF偏移12字节处加载到ACC
lw $t1, 0($sp)     # 从栈顶加载到T1
```

**在PA5中的使用**：
```cpp
emit_load(ACC, 3, SELF, s);  // 生成: lw $a0, 12($s0)
// 从对象偏移3个字（12字节）处加载属性值
```

---

**`li` (Load Immediate)** - 加载立即数到寄存器

```mips
li $dest, immediate
```

**功能**：`$dest = immediate`

**示例**：
```mips
li $t1, 0          # T1 = 0
li $t2, 1          # T2 = 1
li $t3, 4          # T3 = 4
```

**在PA5中的使用**：
```cpp
emit_load_imm(T1, 0, s);     // 生成: li $t1, 0
emit_load_imm(T2, 1, s);     // 生成: li $t2, 1
```

---

**`la` (Load Address)** - 加载地址到寄存器

```mips
la $dest, label
```

**功能**：`$dest = address_of(label)`

**示例**：
```mips
la $a0, str_const0    # ACC = str_const0的地址
la $t1, class_objTab  # T1 = class_objTab的地址
```

**在PA5中的使用**：
```cpp
emit_load_address(ACC, "str_const0", s);  // 生成: la $a0, str_const0
```

---

#### 12.2.2 存储指令

**`sw` (Store Word)** - 将寄存器值存储到内存

```mips
sw $source, offset($base)
```

**功能**：`Memory[$base + offset] = $source`

**示例**：
```mips
sw $a0, 12($s0)    # 将ACC的值存储到SELF偏移12字节处
sw $a0, 0($sp)     # 将ACC的值压栈
```

**在PA5中的使用**：
```cpp
emit_store(ACC, 3, SELF, s);  // 生成: sw $a0, 12($s0)
emit_push(ACC, s);            // 生成: sw $a0, 0($sp); addiu $sp, $sp, -4
```

---

**`move`** - 寄存器间移动数据

```mips
move $dest, $source
```

**功能**：`$dest = $source`

**示例**：
```mips
move $a0, $s0       # ACC = SELF
move $t2, $a0       # T2 = ACC
```

**在PA5中的使用**：
```cpp
emit_move(ACC, SELF, s);  // 生成: move $a0, $s0
emit_move(T2, ACC, s);    // 生成: move $t2, $a0
```

---

### 12.3 算术运算指令

#### 12.3.1 基本算术运算

**`add` (Add)** - 有符号加法

```mips
add $dest, $src1, $src2
```

**功能**：`$dest = $src1 + $src2`（有符号，可能溢出）

**示例**：
```mips
add $t3, $t1, $t2   # T3 = T1 + T2
```

**在PA5中的使用**：
```cpp
emit_add(T3, T1, T2, s);  // 生成: add $t3, $t1, $t2
// 用于整数加法运算
```

---

**`addu` (Add Unsigned)** - 无符号加法

```mips
addu $dest, $src1, $src2
```

**功能**：`$dest = $src1 + $src2`（无符号，不检查溢出）

**示例**：
```mips
addu $t1, $t1, $t2  # T1 = T1 + T2（地址计算）
```

**在PA5中的使用**：
```cpp
emit_addu(T1, T1, T2, s);  // 生成: addu $t1, $t1, $t2
// 用于地址计算
```

---

**`addiu` (Add Immediate Unsigned)** - 立即数无符号加法

```mips
addiu $dest, $src, immediate
```

**功能**：`$dest = $src + immediate`（无符号）

**示例**：
```mips
addiu $sp, $sp, -4   # SP = SP - 4（栈指针减小，压栈）
addiu $sp, $sp, 4    # SP = SP + 4（栈指针增大，弹栈）
addiu $fp, $sp, 4    # FP = SP + 4（设置帧指针）
```

**在PA5中的使用**：
```cpp
emit_addiu(SP, SP, -4, s);   // 生成: addiu $sp, $sp, -4（压栈）
emit_addiu(SP, SP, 4, s);    // 生成: addiu $sp, $sp, 4（弹栈）
emit_addiu(FP, SP, 4, s);    // 生成: addiu $fp, $sp, 4
```

---

**`sub` (Subtract)** - 减法

```mips
sub $dest, $src1, $src2
```

**功能**：`$dest = $src1 - $src2`

**示例**：
```mips
sub $t3, $t1, $t2   # T3 = T1 - T2
```

**在PA5中的使用**：
```cpp
emit_sub(T3, T1, T2, s);  // 生成: sub $t3, $t1, $t2
// 用于整数减法运算
```

---

**`mul` (Multiply)** - 乘法

```mips
mul $dest, $src1, $src2
```

**功能**：`$dest = $src1 * $src2`

**示例**：
```mips
mul $t3, $t1, $t2   # T3 = T1 * T2
```

**在PA5中的使用**：
```cpp
emit_mul(T3, T1, T2, s);  // 生成: mul $t3, $t1, $t2
// 用于整数乘法运算
```

---

**`div` (Divide)** - 除法

```mips
div $dest, $src1, $src2
```

**功能**：`$dest = $src1 / $src2`

**示例**：
```mips
div $t3, $t1, $t2   # T3 = T1 / T2
```

**在PA5中的使用**：
```cpp
emit_div(T3, T1, T2, s);  // 生成: div $t3, $t1, $t2
// 用于整数除法运算
```

---

**`neg` (Negate)** - 取负

```mips
neg $dest, $src
```

**功能**：`$dest = -$src`

**示例**：
```mips
neg $t1, $t1   # T1 = -T1
```

**在PA5中的使用**：
```cpp
emit_neg(T1, T1, s);  // 生成: neg $t1, $t1
// 用于整数取负运算
```

---

#### 12.3.2 逻辑移位指令

**`sll` (Shift Left Logical)** - 逻辑左移

```mips
sll $dest, $src, shamt
```

**功能**：`$dest = $src << shamt`（左移shamt位，相当于乘以2^shamt）

**示例**：
```mips
sll $t2, $t2, 3   # T2 = T2 << 3（相当于 T2 * 8）
```

**在PA5中的使用**：
```cpp
emit_sll(T2, T2, 3, s);  // 生成: sll $t2, $t2, 3
// 用于地址计算：类标签 * 8（每个类在objTab中占2个字）
```

---

### 12.4 分支和跳转指令

#### 12.4.1 条件分支指令

**`beq` (Branch if Equal)** - 相等则跳转

```mips
beq $src1, $src2, label
```

**功能**：如果`$src1 == $src2`，则跳转到`label`

**示例**：
```mips
beq $t1, $zero, label_false   # 如果T1 == 0，跳转到label_false
beq $t1, $t2, label_equal     # 如果T1 == T2，跳转到label_equal
```

**在PA5中的使用**：
```cpp
emit_beq(T1, ZERO, labelnum, s);  // 生成: beq $t1, $zero, label0
// 用于条件判断
```

---

**`bne` (Branch if Not Equal)** - 不等则跳转

```mips
bne $src1, $src2, label
```

**功能**：如果`$src1 != $src2`，则跳转到`label`

**示例**：
```mips
bne $a0, $zero, label_not_void   # 如果ACC != 0，跳转
```

**在PA5中的使用**：
```cpp
emit_bne(ACC, ZERO, labelnum, s);  // 生成: bne $a0, $zero, label0
// 用于检查对象是否为void
```

---

**`beqz` (Branch if Equal to Zero)** - 等于零则跳转

```mips
beqz $src, label
```

**功能**：如果`$src == 0`，则跳转到`label`

**示例**：
```mips
beqz $t1, label_false   # 如果T1 == 0，跳转
```

**在PA5中的使用**：
```cpp
emit_beqz(T1, labelnum, s);  // 生成: beqz $t1, label0
// 用于布尔值判断
```

---

**`blt` (Branch if Less Than)** - 小于则跳转

```mips
blt $src1, $src2, label
```

**功能**：如果`$src1 < $src2`（有符号），则跳转到`label`

**示例**：
```mips
blt $t1, $t2, label_less   # 如果T1 < T2，跳转
```

**在PA5中的使用**：
```cpp
emit_blt(T1, T2, labelnum, s);  // 生成: blt $t1, $t2, label0
// 用于整数比较运算
```

---

**`ble` (Branch if Less or Equal)** - 小于等于则跳转

```mips
ble $src1, $src2, label
```

**功能**：如果`$src1 <= $src2`（有符号），则跳转到`label`

**示例**：
```mips
ble $t1, $t2, label_less_equal   # 如果T1 <= T2，跳转
```

**在PA5中的使用**：
```cpp
emit_bleq(T1, T2, labelnum, s);  // 生成: ble $t1, $t2, label0
// 用于整数比较运算（<=）
```

---

**`bgt` (Branch if Greater Than)** - 大于则跳转

```mips
bgt $src1, $src2, label
```

**功能**：如果`$src1 > $src2`（有符号），则跳转到`label`

**示例**：
```mips
bgt $t1, $t2, label_greater   # 如果T1 > T2，跳转
```

---

**`b` (Branch)** - 无条件跳转

```mips
b label
```

**功能**：无条件跳转到`label`

**示例**：
```mips
b label_finish   # 无条件跳转到label_finish
```

**在PA5中的使用**：
```cpp
emit_branch(labelnum, s);  // 生成: b label0
// 用于循环和条件语句中的跳转
```

---

#### 12.4.2 跳转指令

**`jal` (Jump and Link)** - 跳转并链接（函数调用）

```mips
jal label
```

**功能**：
1. `$ra = PC + 4`（保存返回地址）
2. `PC = label`（跳转到函数）

**示例**：
```mips
jal Object.copy      # 调用Object.copy函数
jal Main_init        # 调用Main_init函数
jal _GenGC_Assign    # 调用GC赋值函数
```

**在PA5中的使用**：
```cpp
emit_jal("Object.copy", s);  // 生成: jal Object.copy
emit_jal("_GenGC_Assign", s);  // 生成: jal _GenGC_Assign
```

---

**`jalr` (Jump and Link Register)** - 通过寄存器跳转并链接

```mips
jalr $reg
```

**功能**：
1. `$ra = PC + 4`（保存返回地址）
2. `PC = $reg`（跳转到寄存器中的地址）

**示例**：
```mips
jalr $t1   # 跳转到T1寄存器中的地址（用于动态方法调用）
```

**在PA5中的使用**：
```cpp
emit_jalr(T1, s);  // 生成: jalr $t1
// 用于通过分发表调用方法
```

---

**`jr` (Jump Register)** - 通过寄存器跳转（返回）

```mips
jr $ra
```

**功能**：`PC = $ra`（返回到调用者）

**示例**：
```mips
jr $ra   # 返回到调用者
```

**在PA5中的使用**：
```cpp
emit_return(s);  // 生成: jr $ra
// 用于函数返回
```

---

### 12.5 栈操作约定

在PA5中，栈的使用遵循以下约定：

#### 12.5.1 栈增长方向

**栈向低地址增长**：
- **压栈（push）**：`SP = SP - 4`，然后存储数据
- **弹栈（pop）**：读取数据，然后`SP = SP + 4`

#### 12.5.2 栈帧布局

方法调用时的栈帧布局（从高地址到低地址）：

```
高地址
  +----------------+
  | 参数N          |  FP + (N+3)*4
  |  ...           |
  | 参数1          |  FP + 4*4
  +----------------+
  | 返回地址(RA)   |  FP + 3*4  (SP+12)
  | SELF           |  FP + 2*4  (SP+8)
  | FP (旧)        |  FP + 1*4  (SP+4)
  +----------------+  <- FP (当前帧指针)
  | let变量1       |  SP + 1*4
  | let变量2       |  SP + 2*4
  | ...            |
  +----------------+  <- SP (当前栈指针)
低地址
```

**偏移量说明**：
- **参数**：从`FP + 4*4`开始（偏移3个字）
- **RA**：`FP + 3*4`（偏移3个字）
- **SELF**：`FP + 2*4`（偏移2个字）
- **FP**：`FP + 1*4`（偏移1个字）
- **let变量**：从`SP + 1*4`开始（偏移1个字）

#### 12.5.3 栈操作示例

**压栈操作**：
```mips
sw $a0, 0($sp)        # 存储ACC到栈顶
addiu $sp, $sp, -4    # SP减小4（栈增长）
```

**弹栈操作**：
```mips
addiu $sp, $sp, 4     # SP增大4（栈收缩）
lw $t1, 0($sp)        # 从栈顶加载到T1
```

**在PA5中的实现**：
```cpp
// 压栈
static void emit_push(char* reg, ostream& str) {
    emit_store(reg, 0, SP, str);      // sw reg, 0($sp)
    emit_addiu(SP, SP, -4, str);      // addiu $sp, $sp, -4
}

// 弹栈（手动实现）
emit_addiu(SP, SP, 4, s);             // addiu $sp, $sp, 4
emit_load(T1, 0, SP, s);               // lw $t1, 0($sp)
```

### 12.6 对象布局

COOL对象在内存中的布局（从偏移0开始）：

```
偏移  内容              说明
----  ----------------  -------------------------
0     class tag        类标签（用于类型识别）
4     size             对象大小（以字为单位）
8     dispatch table   分发表地址
12    attribute 1      第一个属性
16    attribute 2      第二个属性
...   ...              ...
```

**访问方式**：
- **类标签**：`lw $t1, 0($s0)`（偏移0）
- **对象大小**：`lw $t1, 4($s0)`（偏移1个字）
- **分发表**：`lw $t1, 8($s0)`（偏移2个字）
- **属性i**：`lw $t1, (3+i)*4($s0)`（偏移3+i个字）

**在PA5中的使用**：
```cpp
emit_load(T1, 0, ACC, s);   // 加载类标签
emit_load(T1, 2, ACC, s);   // 加载分发表地址
emit_load(T1, 3, ACC, s);   // 加载第一个属性（Int的val字段）
```

### 12.7 实际使用示例

#### 示例1：整数加法运算

```cpp
void plus_class::code(ostream& s, Environment env) {
    // 1. 计算e1，结果在ACC中
    e1->code(s, env);
    
    // 2. 压栈保存e1的结果
    emit_push(ACC, s);  // sw $a0, 0($sp); addiu $sp, $sp, -4
    
    // 3. 计算e2，结果在ACC中
    e2->code(s, env);
    
    // 4. 复制e2的结果（因为要返回新对象）
    emit_jal("Object.copy", s);  // jal Object.copy
    
    // 5. 恢复e1的结果到T1
    emit_addiu(SP, SP, 4, s);    // addiu $sp, $sp, 4
    emit_load(T1, 0, SP, s);      // lw $t1, 0($sp)
    
    // 6. 将e2的结果移到T2
    emit_move(T2, ACC, s);        // move $t2, $a0
    
    // 7. 提取整数部分（偏移3是val字段）
    emit_load(T1, 3, T1, s);      // lw $t1, 12($t1)
    emit_load(T2, 3, T2, s);      // lw $t2, 12($t2)
    
    // 8. 执行加法
    emit_add(T3, T1, T2, s);      // add $t3, $t1, $t2
    
    // 9. 存储结果（ACC指向新对象）
    emit_store(T3, 3, ACC, s);    // sw $t3, 12($a0)
}
```

**生成的汇编代码**：
```mips
# 计算e1
... (e1的代码) ...

# 压栈
sw $a0, 0($sp)
addiu $sp, $sp, -4

# 计算e2
... (e2的代码) ...

# 复制对象
jal Object.copy

# 恢复e1
addiu $sp, $sp, 4
lw $t1, 0($sp)

# 移动e2
move $t2, $a0

# 提取整数
lw $t1, 12($t1)
lw $t2, 12($t2)

# 加法
add $t3, $t1, $t2

# 存储结果
sw $t3, 12($a0)
```

#### 示例2：条件表达式

```cpp
void cond_class::code(ostream& s, Environment env) {
    // 1. 计算条件
    pred->code(s, env);
    
    // 2. 提取布尔值
    emit_fetch_int(T1, ACC, s);  // lw $t1, 12($a0)
    
    // 3. 生成标签
    int label_false = labelnum++;
    int label_finish = labelnum++;
    
    // 4. 条件跳转
    emit_beq(T1, ZERO, label_false, s);  // beq $t1, $zero, label0
    
    // 5. then分支
    then_exp->code(s, env);
    emit_branch(label_finish, s);        // b label1
    
    // 6. else分支
    emit_label_def(label_false, s);      // label0:
    else_exp->code(s, env);
    
    // 7. 结束标签
    emit_label_def(label_finish, s);     // label1:
}
```

**生成的汇编代码**：
```mips
# 计算条件
... (pred的代码) ...

# 提取布尔值
lw $t1, 12($a0)

# 条件跳转
beq $t1, $zero, label0

# then分支
... (then_exp的代码) ...
b label1

# else分支
label0:
... (else_exp的代码) ...

# 结束
label1:
```

#### 示例3：方法调用

```cpp
void dispatch_class::code(ostream& s, Environment env) {
    // 1. 计算参数并压栈（从右到左）
    for (Expression expr : actuals) {
        expr->code(s, env);
        emit_push(ACC, s);
    }
    
    // 2. 计算对象表达式
    expr->code(s, env);
    
    // 3. 检查对象是否为void
    emit_bne(ACC, ZERO, labelnum, s);    // bne $a0, $zero, label0
    emit_load_address(ACC, "str_const0", s);  // la $a0, str_const0
    emit_load_imm(T1, 1, s);             // li $t1, 1
    emit_jal("_dispatch_abort", s);       // jal _dispatch_abort
    emit_label_def(labelnum, s);         // label0:
    
    // 4. 加载分发表
    emit_load(T1, 2, ACC, s);            // lw $t1, 8($a0)
    
    // 5. 获取方法索引并加载方法地址
    int idx = class_node->GetDispatchIdxTab()[name];
    emit_load(T1, idx, T1, s);           // lw $t1, idx*4($t1)
    
    // 6. 调用方法
    emit_jalr(T1, s);                    // jalr $t1
}
```

**生成的汇编代码**：
```mips
# 计算参数（假设有2个参数）
... (arg2的代码) ...
sw $a0, 0($sp)
addiu $sp, $sp, -4

... (arg1的代码) ...
sw $a0, 0($sp)
addiu $sp, $sp, -4

# 计算对象
... (expr的代码) ...

# 检查void
bne $a0, $zero, label0
la $a0, str_const0
li $t1, 1
jal _dispatch_abort
label0:

# 加载分发表
lw $t1, 8($a0)

# 加载方法地址（假设索引为2）
lw $t1, 8($t1)

# 调用方法
jalr $t1
```

### 12.8 指令速查表

| 指令 | 格式 | 功能 | 常用场景 |
|------|------|------|----------|
| `lw` | `lw $dest, offset($base)` | 从内存加载 | 加载属性、从栈加载 |
| `sw` | `sw $src, offset($base)` | 存储到内存 | 存储属性、压栈 |
| `li` | `li $dest, imm` | 加载立即数 | 加载常量 |
| `la` | `la $dest, label` | 加载地址 | 加载字符串/对象地址 |
| `move` | `move $dest, $src` | 寄存器移动 | 复制寄存器值 |
| `add` | `add $dest, $src1, $src2` | 有符号加法 | 整数运算 |
| `addu` | `addu $dest, $src1, $src2` | 无符号加法 | 地址计算 |
| `addiu` | `addiu $dest, $src, imm` | 立即数加法 | 栈指针调整 |
| `sub` | `sub $dest, $src1, $src2` | 减法 | 整数运算 |
| `mul` | `mul $dest, $src1, $src2` | 乘法 | 整数运算 |
| `div` | `div $dest, $src1, $src2` | 除法 | 整数运算 |
| `neg` | `neg $dest, $src` | 取负 | 整数运算 |
| `sll` | `sll $dest, $src, shamt` | 左移 | 地址计算（*2^shamt） |
| `beq` | `beq $src1, $src2, label` | 相等跳转 | 条件判断 |
| `bne` | `bne $src1, $src2, label` | 不等跳转 | void检查 |
| `beqz` | `beqz $src, label` | 为零跳转 | 布尔判断 |
| `blt` | `blt $src1, $src2, label` | 小于跳转 | 整数比较 |
| `ble` | `ble $src1, $src2, label` | 小于等于跳转 | 整数比较 |
| `b` | `b label` | 无条件跳转 | 循环、条件结束 |
| `jal` | `jal label` | 函数调用 | 调用方法 |
| `jalr` | `jalr $reg` | 寄存器跳转调用 | 动态方法调用 |
| `jr` | `jr $ra` | 返回 | 函数返回 |

### 12.9 常见错误和注意事项

1. **栈操作必须成对**：每次`addiu $sp, $sp, -4`后必须有对应的`addiu $sp, $sp, 4`

2. **偏移量计算**：
   - 内存偏移以**字节**为单位
   - 一个字 = 4字节
   - `offset($base)`中的offset是字节偏移

3. **寄存器约定**：
   - ACC用于表达式结果
   - 不要破坏SELF、FP、RA（除非明确需要）

4. **标签唯一性**：使用全局`labelnum`确保标签唯一

5. **方法调用后**：
   - 结果在ACC中
   - 需要手动清理参数（`addiu $sp, $sp, N*4`）

6. **对象访问**：
   - 属性偏移从3开始（前3个字是tag、size、dispatch table）
   - 使用`lw $reg, (3+idx)*4($s0)`访问属性

---

**掌握了这些MIPS指令，你就可以完成PA5的代码生成了！** 🎯

---

## 十四、继承问题的处理

继承是面向对象编程的核心特性，PA5代码生成器必须正确处理类的继承关系。本节详细介绍如何处理继承相关的复杂情况。

### 14.1 继承链的构建

#### 14.1.1 继承树的结构

COOL语言的类继承关系形成一棵树：
- **根节点**：`Object`类
- **子节点**：用户定义的类
- **单继承**：每个类只能有一个父类

**示例继承关系**：
```
Object
├── IO
├── Int
├── Bool
├── String
└── A
    └── B
        └── C
```

#### 14.1.2 继承链的获取

`GetInheritance()`方法返回从`Object`到当前类的完整继承链：

```cpp
std::vector<CgenNode*> CgenNode::GetInheritance() {
    if (inheritance.empty()) {
        CgenNode* class_node = this;
        // 从当前类向上遍历到Object
        while (class_node->name != No_class) {
            inheritance.push_back(class_node);
            class_node = class_node->get_parentnd();
        }
        // 反转，使Object在第一个位置
        std::reverse(inheritance.begin(), inheritance.end());
    }
    return inheritance;
}
```

**示例**：对于类`C`（继承自`B`，`B`继承自`A`，`A`继承自`Object`）：
```cpp
GetInheritance() = [Object, A, B, C]
```

### 14.2 完整属性列表（GetFullAttribs）

#### 14.2.1 问题：属性继承

子类继承父类的所有属性，属性在对象中的布局必须考虑继承关系。

**示例**：
```cool
class A {
    x : Int;
    y : Int;
};

class B inherits A {
    z : Int;
};
```

`B`类的对象布局：
```
偏移  内容      说明
----  --------  -------------------------
0     tag       B类标签
4     size      对象大小
8     dispTab   分发表地址
12    x         A的属性
16    y         A的属性
20    z         B的属性
```

#### 14.2.2 实现：收集所有属性

```cpp
std::vector<attr_class*> CgenNode::GetFullAttribs() {
    if (m_full_attribs.empty()) {
        // 获取继承链
        std::vector<CgenNode*> inheritance = GetInheritance();
        
        // 按继承顺序收集所有属性
        for (CgenNode* class_node : inheritance) {
            Features features = class_node->features;
            for (int j = features->first(); features->more(j); j = features->next(j)) {
                Feature feature = features->nth(j);
                if (!feature->IsMethod()) {  // 只收集属性，不收集方法
                    m_full_attribs.push_back((attr_class*)feature);
                }
            }
        }
        
        // 建立属性名到索引的映射
        for (int i = 0; i < m_full_attribs.size(); ++i) {
            m_attrib_idx_tab[m_full_attribs[i]->name] = i;
        }
    }
    return m_full_attribs;
}
```

**关键点**：
1. **顺序很重要**：先父类属性，后子类属性
2. **索引映射**：建立属性名到偏移量的映射
3. **只收集属性**：跳过方法（`IsMethod()`检查）

#### 14.2.3 属性访问

访问属性时，使用`GetAttribIdxTab()`获取索引：

```cpp
void assign_class::code(ostream& s, Environment env) {
    expr->code(s, env);  // 计算表达式
    
    int idx = env.LookUpAttrib(name);  // 获取属性索引
    if (idx != -1) {
        emit_store(ACC, idx + 3, SELF, s);  // 存储到对象偏移(idx+3)*4处
    }
}
```

**偏移量计算**：
- 属性索引从0开始
- 对象前3个字是tag、size、dispatch table
- 属性偏移 = `(idx + 3) * 4`字节

### 14.3 完整方法列表（GetFullMethods）

#### 14.3.1 问题：方法重写（Override）

子类可以重写父类的方法，分发表中必须使用子类的方法实现。

**示例**：
```cool
class A {
    method1() : Int { 1 };
};

class B inherits A {
    method1() : Int { 2 };  # 重写父类方法
    method2() : Int { 3 };
};
```

`B`类的分发表应该包含：
- `method1` → `B.method1`（不是`A.method1`）
- `method2` → `B.method2`

#### 14.3.2 实现：构建分发表

```cpp
std::vector<method_class*> CgenNode::GetFullMethods() {
    if (m_full_methods.empty()) {
        // 获取继承链
        std::vector<CgenNode*> inheritance = GetInheritance();
        
        // 按继承顺序遍历
        for (CgenNode* _class_node : inheritance) {
            Symbol _class_name = _class_node->name;
            std::vector<method_class*> _methods = _class_node->GetMethods();
            
            for (method_class* _method : _methods) {
                Symbol _method_name = _method->name;
                
                if (m_dispatch_idx_tab.find(_method_name) == m_dispatch_idx_tab.end()) {
                    // 新方法：添加到分发表
                    m_full_methods.push_back(_method);
                    m_dispatch_idx_tab[_method_name] = m_full_methods.size() - 1;
                    m_dispatch_class_tab[_method_name] = _class_name;
                } else {
                    // 方法已存在：重写（使用子类的方法）
                    int idx = m_dispatch_idx_tab[_method_name];
                    m_full_methods[idx] = _method;  // 替换为子类方法
                    m_dispatch_class_tab[_method_name] = _class_name;
                }
            }
        }
    }
    return m_full_methods;
}
```

**关键点**：
1. **先父类后子类**：按继承顺序遍历
2. **方法重写**：如果方法已存在，用子类方法替换
3. **索引映射**：建立方法名到分发表索引的映射
4. **类映射**：记录每个方法定义在哪个类中

#### 14.3.3 分发表的生成

```cpp
void CgenClassTable::code_dispatchTabs() {
    std::vector<CgenNode*> class_nodes = GetClassNodes();
    
    for (CgenNode* _class_node : class_nodes) {
        emit_disptable_ref(_class_node->name, str);
        str << LABEL;
        
        // 获取完整方法列表
        std::vector<method_class*> full_methods = _class_node->GetFullMethods();
        std::map<Symbol, Symbol> dispatch_class_tab = _class_node->GetDispatchClassTab();
        std::map<Symbol, int> dispatch_idx_tab = _class_node->GetDispatchIdxTab();
        
        // 为每个方法生成分发表项
        for (method_class* _method : full_methods) {
            Symbol _method_name = _method->name;
            Symbol _class_name = dispatch_class_tab[_method_name];  // 方法定义的类
            int _idx = dispatch_idx_tab[_method_name];
            
            str << "\t# method # " << _idx << endl;
            str << WORD;
            emit_method_ref(_class_name, _method_name, str);  // 生成: Class.method
            str << endl;
        }
    }
}
```

**示例**：对于`B`类（继承自`A`），分发表：

```mips
B_dispTab:
.word A.method1    # 如果A有method1，会被B.method1替换
.word B.method2    # B的方法
```

### 14.4 类初始化顺序

#### 14.4.1 问题：父类必须先初始化

创建对象时，必须先调用父类的初始化方法，再初始化子类的属性。

**示例**：
```cool
class A {
    x : Int <- 10;
};

class B inherits A {
    y : Int <- 20;
};
```

创建`B`对象时：
1. 先调用`A_init`（初始化`x = 10`）
2. 再初始化`y = 20`

#### 14.4.2 实现：初始化方法

```cpp
void CgenNode::code_init(ostream& s) {
    s << get_name() << CLASSINIT_SUFFIX << LABEL;
    
    // 栈帧设置
    emit_addiu(SP, SP, -12, s);
    emit_store(FP, 3, SP, s);
    emit_store(SELF, 2, SP, s);
    emit_store(RA, 1, SP, s);
    emit_addiu(FP, SP, 4, s);
    emit_move(SELF, ACC, s);
    
    // 1. 先初始化父类
    Symbol parent_name = get_parentnd()->name;
    if (parent_name != No_class) {
        s << "\t# init parent" << endl;
        s << JAL;
        emit_init_ref(parent_name, s);  // 调用父类初始化方法
        s << endl << endl;
    }
    
    // 2. 初始化当前类的属性
    std::vector<attr_class*> attribs = GetAttribs();  // 只获取当前类的属性
    std::map<Symbol, int> attrib_idx_tab = GetAttribIdxTab();  // 使用完整索引表
    
    for (attr_class* attrib : attribs) {
        int idx = attrib_idx_tab[attrib->name];  // 获取完整索引
        
        if (attrib->init->IsEmpty()) {
            // 默认初始化（基本类型）
            if (attrib->type_decl == Str) {
                emit_load_string(ACC, stringtable.lookup_string(""), s);
                emit_store(ACC, 3 + idx, SELF, s);
            } else if (attrib->type_decl == Int) {
                emit_load_int(ACC, inttable.lookup_string("0"), s);
                emit_store(ACC, 3 + idx, SELF, s);
            } else if (attrib->type_decl == Bool) {
                emit_load_bool(ACC, BoolConst(0), s);
                emit_store(ACC, 3 + idx, SELF, s);
            }
        } else {
            // 使用初始化表达式
            Environment env;
            env.m_class_node = this;
            attrib->init->code(s, env);
            emit_store(ACC, 3 + idx, SELF, s);
        }
    }
    
    // 返回SELF
    emit_move(ACC, SELF, s);
    
    // 恢复栈帧
    emit_load(FP, 3, SP, s);
    emit_load(SELF, 2, SP, s);
    emit_load(RA, 1, SP, s);
    emit_addiu(SP, SP, 12, s);
    emit_return(s);
}
```

**关键点**：
1. **先父后子**：必须先调用父类初始化
2. **索引使用**：使用`GetAttribIdxTab()`获取完整索引（考虑继承）
3. **只初始化当前类属性**：使用`GetAttribs()`而不是`GetFullAttribs()`

### 14.5 动态分发（Dynamic Dispatch）

#### 14.5.1 问题：运行时方法选择

方法调用时，根据对象的实际类型选择方法实现。

**示例**：
```cool
class A {
    method() : Int { 1 };
};

class B inherits A {
    method() : Int { 2 };
};

let x : A <- new B in
    x.method()  # 应该调用B.method，返回2
```

#### 14.5.2 实现：通过分发表调用

```cpp
void dispatch_class::code(ostream& s, Environment env) {
    // 1. 计算参数并压栈
    std::vector<Expression> actuals = GetActuals();
    for (Expression expr : actuals) {
        expr->code(s, env);
        emit_push(ACC, s);
        env.AddObstacle();
    }
    
    // 2. 计算对象表达式
    expr->code(s, env);
    
    // 3. 检查对象是否为void
    emit_bne(ACC, ZERO, labelnum, s);
    emit_load_address(ACC, "str_const0", s);
    emit_load_imm(T1, 1, s);
    emit_jal("_dispatch_abort", s);
    emit_label_def(labelnum, s);
    ++labelnum;
    
    // 4. 确定静态类型（用于获取方法索引）
    Symbol _class_name = env.m_class_node->name;
    if (expr->get_type() != SELF_TYPE) {
        _class_name = expr->get_type();
    }
    CgenNode* _class_node = codegen_classtable->GetClassNode(_class_name);
    
    // 5. 从对象加载分发表（运行时类型）
    emit_load(T1, 2, ACC, s);  // T1 = ACC.dispTab
    
    // 6. 获取方法索引（静态类型）
    int idx = _class_node->GetDispatchIdxTab()[name];
    
    // 7. 从分发表加载方法地址
    emit_load(T1, idx, T1, s);  // T1 = dispTab[idx]
    
    // 8. 调用方法（动态分发）
    emit_jalr(T1, s);  // 跳转到T1中的地址
}
```

**关键点**：
1. **分发表在对象中**：每个对象都有指向其类的分发表的指针
2. **索引由静态类型决定**：方法在分发表中的位置由静态类型决定
3. **方法由运行时类型决定**：实际调用的方法由对象的实际类型决定

#### 14.5.3 静态分发（Static Dispatch）

静态分发明确指定调用哪个类的方法：

```cpp
void static_dispatch_class::code(ostream& s, Environment env) {
    // ... 参数计算和压栈 ...
    
    // 使用指定的类型（type_name）的分发表
    Symbol _class_name = type_name;
    CgenNode* _class_node = codegen_classtable->GetClassNode(type_name);
    
    // 直接加载指定类的分发表
    std::string addr = type_name->get_string();
    addr += DISPTAB_SUFFIX;
    emit_load_address(T1, addr.c_str(), s);  // T1 = Type.dispTab
    
    // 获取方法索引
    int idx = _class_node->GetDispatchIdxTab()[name];
    emit_load(T1, idx, T1, s);
    
    // 调用方法
    emit_jalr(T1, s);
}
```

### 14.6 类标签（Class Tags）

#### 14.6.1 问题：类型识别

运行时需要识别对象的类型，用于`case`表达式和类型检查。

#### 14.6.2 实现：分配类标签

```cpp
std::vector<CgenNode*> CgenClassTable::GetClassNodes() {
    if (m_class_nodes.empty()) {
        // 收集所有类
        for (List<CgenNode> *l = nds; l; l = l->tl()) {
            CgenNode* class_node = l->hd();
            m_class_nodes.push_back(class_node);
        }
        
        // 反转，使Object在第一个位置
        std::reverse(m_class_nodes.begin(), m_class_nodes.end());
        
        // 分配标签
        for (int i = 0; i < m_class_nodes.size(); ++i) {
            m_class_nodes[i]->class_tag = i;
            m_class_tags.insert(std::make_pair(m_class_nodes[i]->get_name(), i));
        }
    }
    return m_class_nodes;
}
```

**标签分配规则**：
- `Object` = 0
- `IO` = 1
- `Int` = 2
- `Bool` = 3
- `String` = 4
- 用户定义的类依次分配

#### 14.6.3 类型检查

在`case`表达式中使用类标签进行类型匹配：

```cpp
void typcase_class::code(ostream& s, Environment env) {
    expr->code(s, env);
    
    // 加载对象的类标签
    emit_load(T1, 0, ACC, s);  // T1 = ACC.tag
    
    // 对每个case分支，检查标签是否匹配
    std::vector<branch_class*> _cases = GetCases();
    for (branch_class* _case : _cases) {
        Symbol _type = _case->type_decl;
        int _tag = codegen_classtable->GetClassTags()[_type];
        
        // 检查标签是否匹配
        emit_load_imm(T2, _tag, s);
        emit_beq(T1, T2, labelnum, s);
        // ... 处理匹配的情况 ...
    }
}
```

### 14.7 常见问题和解决方案

#### 14.7.1 问题1：属性索引错误

**症状**：访问属性时访问到错误的位置

**原因**：使用了`GetAttribs()`的索引而不是`GetAttribIdxTab()`的索引

**解决**：始终使用`GetAttribIdxTab()`获取属性索引

```cpp
// 错误
std::vector<attr_class*> attribs = GetAttribs();
int idx = 0;  // 错误：只考虑当前类

// 正确
std::map<Symbol, int> attrib_idx_tab = GetAttribIdxTab();
int idx = attrib_idx_tab[name];  // 正确：考虑继承
```

#### 14.7.2 问题2：方法重写未生效

**症状**：调用子类方法时仍调用父类方法

**原因**：分发表构建时未正确处理方法重写

**解决**：确保在`GetFullMethods()`中，子类方法替换父类方法

```cpp
// 关键代码
if (m_dispatch_idx_tab.find(_method_name) == m_dispatch_idx_tab.end()) {
    // 新方法：添加
    m_full_methods.push_back(_method);
    m_dispatch_idx_tab[_method_name] = m_full_methods.size() - 1;
} else {
    // 已存在：替换（重写）
    int idx = m_dispatch_idx_tab[_method_name];
    m_full_methods[idx] = _method;  // 用子类方法替换
}
```

#### 14.7.3 问题3：初始化顺序错误

**症状**：对象属性未正确初始化

**原因**：未先调用父类初始化方法

**解决**：在`code_init()`中先调用父类初始化

```cpp
// 先初始化父类
Symbol parent_name = get_parentnd()->name;
if (parent_name != No_class) {
    emit_jal(emit_init_ref(parent_name, s), s);
}

// 再初始化当前类属性
// ...
```

#### 14.7.4 问题4：分发表索引不一致

**症状**：方法调用时访问到错误的方法

**原因**：不同类的方法索引不一致

**解决**：确保所有类使用相同的分发表结构（方法顺序一致）

**关键**：`GetFullMethods()`必须按继承顺序构建，确保：
- 所有类的方法顺序一致
- 方法索引在所有类中相同
- 重写的方法使用相同的索引

### 14.8 完整示例

考虑以下继承关系：

```cool
class A {
    x : Int <- 1;
    method1() : Int { 10 };
    method2() : Int { 20 };
};

class B inherits A {
    y : Int <- 2;
    method1() : Int { 11 };  # 重写
    method3() : Int { 30 };
};
```

**属性布局**（`B`对象）：
```
偏移  内容
----  --------
0     B类标签
4     大小(5)
8     B_dispTab
12    x (A的属性)
16    y (B的属性)
```

**分发表**（`B_dispTab`）：
```
索引  方法        实现类
----  ----------  --------
0     method1     B.method1  (重写A.method1)
1     method2     A.method2  (继承)
2     method3     B.method3  (B的方法)
```

**初始化顺序**：
```mips
B_init:
    # 调用父类初始化
    jal A_init
    
    # 初始化B的属性y
    la $a0, int_const0  # 加载2
    sw $a0, 16($s0)     # 存储到y
    
    move $a0, $s0
    jr $ra
```

---

**掌握了继承问题的处理，你就能正确处理复杂的面向对象代码生成了！** 🎯

